diff -r -u tlc-src-1_29/tlc/custom.properties tlc-src-1_29-patched/tlc/custom.properties
--- tlc-src-1_29/tlc/custom.properties	2011-11-28 10:07:45.996218800 +0000
+++ tlc-src-1_29-patched/tlc/custom.properties	2011-11-28 12:02:51.961217400 +0000
@@ -27,7 +27,8 @@
 # platform.
 # Note that J2SE 1.4.2 or higher is required for TrueZIP and the recommended
 # implementation is Sun's JDK 1.4.2_07 or higher.
-platform.home=C:\\j2sdk1.4.2_09
+# platform.home=C:\\j2sdk1.4.2_09
+platform.home=C:\\Program Files\\Java\\jdk1.6.0_25
 platform.bootcp=${platform.home}/jre/lib
 platform.java=${platform.home}/bin/java
 platform.javac=${platform.home}/bin/javac
@@ -37,8 +38,9 @@
 
 # Point to your local copy of Apache's commons-codec JAR, version 1.3 or higher.
 # Available at http://jakarta.apache.org/commons/codec.
-libs.commons-codec.classpath=D:\\Dateien_von_Christian\\Resources\\Java\\commons\\codec\\dist\\commons-codec-1.3.jar
+#libs.commons-codec.classpath=D:\\Dateien_von_Christian\\Resources\\Java\\commons\\codec\\dist\\commons-codec-1.3.jar
+libs.commons-codec.classpath=D:/workspaces/V3.4.1/SOURCE/root/projects/3rd-party/lib/commons/commons-codec-1.3.jar;D:/workspaces/V3.4.1/SOURCE/root/projects/3rd-party/lib/commons/commons-logging-1.1.jar
 
 # Do NOT edit the following properties.
 libs.TrueSwing.classpath=../swing/dist/trueswing.jar
-libs.TrueXML.classpath=../xml/dist/truexml.jar
+libs.TrueXML.classpath=../xml/dist/truexml.jar;D:/workspaces/V3.4.1/SOURCE/root/projects/3rd-party/lib/commons/commons-logging-1.1.jar
Only in tlc-src-1_29-patched/tlc/license: build
Only in tlc-src-1_29-patched/tlc/license: dist
diff -r -u tlc-src-1_29/tlc/license/nbproject/build-impl.xml tlc-src-1_29-patched/tlc/license/nbproject/build-impl.xml
--- tlc-src-1_29/tlc/license/nbproject/build-impl.xml	2006-08-09 18:55:20.000000000 +0100
+++ tlc-src-1_29-patched/tlc/license/nbproject/build-impl.xml	2011-11-28 10:58:31.138391000 +0000
@@ -38,7 +38,7 @@
         <!-- The two properties below are usually overridden -->
         <!-- by the active platform. Just a fallback. -->
         <property name="default.javac.source" value="1.4"/>
-        <property name="default.javac.target" value="1.4"/>
+        <property name="default.javac.target" value="1.6"/>
     </target>
     <target name="-init-project" depends="-pre-init,-init-private,-init-user">
         <property file="nbproject/project.properties"/>
diff -r -u tlc-src-1_29/tlc/license/nbproject/project.properties tlc-src-1_29-patched/tlc/license/nbproject/project.properties
--- tlc-src-1_29/tlc/license/nbproject/project.properties	2006-06-12 15:53:22.000000000 +0100
+++ tlc-src-1_29-patched/tlc/license/nbproject/project.properties	2011-11-28 10:58:31.151391700 +0000
@@ -24,7 +24,7 @@
 javac.compilerargs=
 javac.deprecation=true
 javac.source=1.4
-javac.target=1.4
+javac.target=1.6
 javac.test.classpath=\
     ${javac.classpath}:\
     ${build.classes.dir}:\
diff -r -u tlc-src-1_29/tlc/license/src/de/schlichtherle/license/LicenseManager.java tlc-src-1_29-patched/tlc/license/src/de/schlichtherle/license/LicenseManager.java
--- tlc-src-1_29/tlc/license/src/de/schlichtherle/license/LicenseManager.java	2006-07-28 20:03:38.000000000 +0100
+++ tlc-src-1_29-patched/tlc/license/src/de/schlichtherle/license/LicenseManager.java	2011-12-02 17:35:50.254882300 +0000
@@ -37,6 +37,9 @@
 import javax.security.auth.x500.X500Principal;
 import javax.swing.filechooser.FileFilter;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
 /**
  * This is the top level class which manages all licensing aspects like for
  * instance the creation, installation and verification of license keys.
@@ -60,6 +63,9 @@
             = new ObfuscatedString(new long[] {
         0xD65FA96737AE2CB5L, 0xE804D1A38CF9A413L
     }).toString(); /* => "license" */
+    
+    /** The logger. */
+    private static Log logger = LogFactory.getLog(LicenseManager.class);
 
     /**
      * The suffix for files which hold license certificates.
@@ -573,21 +579,71 @@
      */
     protected synchronized LicenseContent verify(final LicenseNotary notary)
     throws Exception {
-        GenericCertificate certificate = getCertificate();
-        if (certificate != null)
-            return (LicenseContent) certificate.getContent();
-
-        // Load license key from preferences, 
-        final byte[] key = getLicenseKey();
-        if (key == null)
-            throw new NoLicenseInstalledException(getLicenseParam().getSubject());
-        certificate = getPrivacyGuard().key2cert(key);
-        notary.verify(certificate);
-        final LicenseContent content = (LicenseContent) certificate.getContent();
-        validate(content);
-        setCertificate(certificate);
+        try
+        {
+            GenericCertificate certificate = getCertificate();
+            if (certificate != null)
+            {
+                LicenseContent content = (LicenseContent) certificate.getContent();
+                if (logger.isDebugEnabled())
+                {
+                    logger.debug("LicenseManager: Return content from certificate");
+                }
+                return content;
+            }
+            
+            // Load license key from preferences, 
+            final byte[] key = getLicenseKey();
+            if (key == null)
+            {
+                throw new NoLicenseInstalledException(getLicenseParam().getSubject());
+            }
+            PrivacyGuard guard = getPrivacyGuard();
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: Guard is "+((guard == null) ? "null" : "NOT null"));
+            }
+            certificate = guard.key2cert(key);
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: certificate is "+((certificate == null) ? "null" : "NOT null"));
+                logger.debug("LicenseManager: notary is "+((notary == null) ? "null" : "NOT null"));
+            }
+            notary.verify(certificate);
+            final LicenseContent content = (LicenseContent) certificate.getContent();
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: content is "+((content == null) ? "null" : "NOT null"));
+            }
+            validate(content);
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: set certificate");
+            }
+            setCertificate(certificate);
 
-        return content;
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: Return content via key");
+            }
+            return content;
+        }
+        catch (final Exception e)
+        {
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: ", e);
+            }
+            throw e;
+        }
+        catch (final Error e)
+        {
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("LicenseManager: ", e);
+            }
+            throw e;
+        }
     }
     
     /**
@@ -711,7 +767,7 @@
      *     time must match their restrictions.
      * <li>'consumerType' must be provided and 'consumerAmount' must be
      *     positive. If a user preference node is provided in the license
-     *     parameters, 'consumerType' must also match “User” (whereby case
+     *     parameters, 'consumerType' must also match ï¿½Userï¿½ (whereby case
      *     is ignored) and 'consumerAmount' must equal 1.
      * </ul>
      * <p>
diff -r -u tlc-src-1_29/tlc/license/src/de/schlichtherle/license/ftp/LicenseManager.java tlc-src-1_29-patched/tlc/license/src/de/schlichtherle/license/ftp/LicenseManager.java
--- tlc-src-1_29/tlc/license/src/de/schlichtherle/license/ftp/LicenseManager.java	2006-07-28 21:01:32.000000000 +0100
+++ tlc-src-1_29-patched/tlc/license/src/de/schlichtherle/license/ftp/LicenseManager.java	2011-12-02 16:49:43.188785500 +0000
@@ -35,6 +35,9 @@
 import java.security.cert.CertificateException;
 import javax.security.auth.x500.X500Principal;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
 /**
  * Extends {@link de.schlichtherle.license.LicenseManager} in order to provide
  * additional functionality required to manage a free trial period (FTP).
@@ -59,6 +62,9 @@
         0x73F69B7ABA25F620L, 0x40BA225C709D724EL
     }).toString(); /* => "ftpDays" */
 
+    /** The logger. */
+    private static Log logger = LogFactory.getLog(LicenseManager.class);
+
     private LicenseNotary ftpNotary;
 
     private static final String CN_FTP_USER = CN + Resources.getString(
@@ -133,32 +139,81 @@
     protected synchronized LicenseContent verify(final LicenseNotary notary)
     throws Exception {
         try {
-            return super.verify(notary);
-        } catch (Exception exc) {
-            // Checking a regular license failed, now check for an FTP license.
-
-            // Init.
-            final LicenseParam param = (LicenseParam) getLicenseParam();
-            final LicenseNotary ftpNotary = getFTPLicenseNotary();
-
-            // Check FTP license key suspect.
-            final byte[] key = getLicenseKey();
-            if (key != null)
-                return super.verify(ftpNotary);
-
-            // No license key installed:
-            // Check if the consumer is eligible for an FTP license.
-            if (!param.isFTPEligible())
-                throw new NoLicenseInstalledException(param.getSubject());
-            
-            // Create and install an FTP license key.
-            LicenseContent content = param.createFTPLicenseContent();
-            content.setNotAfter(ftpNotAfter(param.getFTPDays())); // enforce expire date
-            content = install(create(content, ftpNotary), ftpNotary); // reassign because of clone
-            param.removeFTPEligibility();
-            param.ftpGranted(content);
-
-            return content; // content of FTP license
+            try {
+                LicenseContent content = super.verify(notary);
+                if (logger.isDebugEnabled())
+                {
+                    logger.debug("ftp.LicenseManager: Return regular license.");
+                }
+                return content;
+            } catch (Exception exc) {
+                // Checking a regular license failed, now check for an FTP license.
+
+                if (logger.isDebugEnabled())
+                {
+                    logger.debug("ftp.LicenseManager: Checking a regular license failed, now check for an FTP license.");
+                }
+
+                // Init.
+                final LicenseParam param = (LicenseParam) getLicenseParam();
+                final LicenseNotary ftpNotary = getFTPLicenseNotary();
+
+                // Check FTP license key suspect.
+                final byte[] key = getLicenseKey();
+                if (key != null)
+                {
+                    LicenseContent content = super.verify(ftpNotary);
+                    if (logger.isDebugEnabled())
+                    {
+                        logger.debug("ftp.LicenseManager: Return FTP license.");
+                    }
+                    return content;
+                }
+
+                // No license key installed:
+                // Check if the consumer is eligible for an FTP license.
+                if (!param.isFTPEligible())
+                {
+                    if (logger.isDebugEnabled())
+                    {
+                        logger.debug("ftp.LicenseManager: No FTP license eligiblity.");
+                    }
+                    throw new NoLicenseInstalledException(param.getSubject());
+                }
+                
+                // Create and install an FTP license key.
+                if (logger.isDebugEnabled())
+                {
+                    logger.debug("ftp.LicenseManager: Create FTP license.");
+                }
+                LicenseContent content = param.createFTPLicenseContent();
+                content.setNotAfter(ftpNotAfter(param.getFTPDays())); // enforce expire date
+                content = install(create(content, ftpNotary), ftpNotary); // reassign because of clone
+                param.removeFTPEligibility();
+                param.ftpGranted(content);
+
+                if (logger.isDebugEnabled())
+                {
+                    logger.debug("ftp.LicenseManager: Return new FTP license.");
+                }
+                return content; // content of FTP license
+            }
+        }
+        catch (final Exception e)
+        {
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("ftp.LicenseManager: ", e);
+            }
+            throw e;
+        }
+        catch (final Error e)
+        {
+            if (logger.isDebugEnabled())
+            {
+                logger.debug("ftp.LicenseManager: ", e);
+            }
+            throw e;
         }
     }
 
Only in tlc-src-1_29-patched/tlc/swing: build
Only in tlc-src-1_29-patched/tlc/swing: dist
diff -r -u tlc-src-1_29/tlc/swing/nbproject/build-impl.xml tlc-src-1_29-patched/tlc/swing/nbproject/build-impl.xml
--- tlc-src-1_29/tlc/swing/nbproject/build-impl.xml	2006-08-13 16:51:02.000000000 +0100
+++ tlc-src-1_29-patched/tlc/swing/nbproject/build-impl.xml	2011-11-28 10:58:31.162392400 +0000
@@ -38,7 +38,7 @@
         <!-- The two properties below are usually overridden -->
         <!-- by the active platform. Just a fallback. -->
         <property name="default.javac.source" value="1.4"/>
-        <property name="default.javac.target" value="1.4"/>
+        <property name="default.javac.target" value="1.6"/>
     </target>
     <target name="-init-project" depends="-pre-init,-init-private,-init-user">
         <property file="nbproject/project.properties"/>
diff -r -u tlc-src-1_29/tlc/swing/nbproject/project.properties tlc-src-1_29-patched/tlc/swing/nbproject/project.properties
--- tlc-src-1_29/tlc/swing/nbproject/project.properties	2006-06-12 15:53:30.000000000 +0100
+++ tlc-src-1_29-patched/tlc/swing/nbproject/project.properties	2011-11-28 10:58:31.173393000 +0000
@@ -22,7 +22,7 @@
 javac.compilerargs=
 javac.deprecation=true
 javac.source=1.4
-javac.target=1.4
+javac.target=1.6
 javac.test.classpath=\
     ${javac.classpath}:\
     ${build.classes.dir}:\
Only in tlc-src-1_29-patched/tlc/xml/build/classes: de
Only in tlc-src-1_29-patched/tlc/xml: dist
diff -r -u tlc-src-1_29/tlc/xml/nbproject/build-impl.xml tlc-src-1_29-patched/tlc/xml/nbproject/build-impl.xml
--- tlc-src-1_29/tlc/xml/nbproject/build-impl.xml	2006-08-19 13:47:04.000000000 +0100
+++ tlc-src-1_29-patched/tlc/xml/nbproject/build-impl.xml	2011-11-28 10:58:14.969466200 +0000
@@ -38,7 +38,7 @@
         <!-- The two properties below are usually overridden -->
         <!-- by the active platform. Just a fallback. -->
         <property name="default.javac.source" value="1.4"/>
-        <property name="default.javac.target" value="1.4"/>
+        <property name="default.javac.target" value="1.6"/>
     </target>
     <target name="-init-project" depends="-pre-init,-init-private,-init-user">
         <property file="nbproject/project.properties"/>
diff -r -u tlc-src-1_29/tlc/xml/nbproject/project.properties tlc-src-1_29-patched/tlc/xml/nbproject/project.properties
--- tlc-src-1_29/tlc/xml/nbproject/project.properties	2006-08-19 13:47:02.000000000 +0100
+++ tlc-src-1_29-patched/tlc/xml/nbproject/project.properties	2011-11-28 10:56:01.328822400 +0000
@@ -23,7 +23,7 @@
 javac.compilerargs=
 javac.deprecation=true
 javac.source=1.4
-javac.target=1.4
+javac.target=1.6
 javac.test.classpath=\
     ${javac.classpath}:\
     ${build.classes.dir}:\
diff -r -u tlc-src-1_29/tlc/xml/src/de/schlichtherle/xml/PersistenceService.java tlc-src-1_29-patched/tlc/xml/src/de/schlichtherle/xml/PersistenceService.java
--- tlc-src-1_29/tlc/xml/src/de/schlichtherle/xml/PersistenceService.java	2006-07-27 18:28:54.000000000 +0100
+++ tlc-src-1_29-patched/tlc/xml/src/de/schlichtherle/xml/PersistenceService.java	2010-12-23 14:28:50.000000000 +0000
@@ -17,6 +17,10 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ * 
+ * 2010 - Alfresco Software, Ltd.
+ * Alfresco Software has modified source of this file
+ * The details of changes as svn diff can be found in svn at location root/enterpriseprojects/3rd-party/src 
  */
 
 package de.schlichtherle.xml;
@@ -24,8 +28,8 @@
 import java.beans.Encoder;
 import java.beans.ExceptionListener;
 import java.beans.PersistenceDelegate;
-import java.beans.XMLEncoder;
 import java.beans.XMLDecoder;
+import java.beans.XMLEncoder;
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
@@ -34,16 +38,12 @@
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.InputStream;
-import java.io.IOException;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.UndeclaredThrowableException;
 import java.util.HashMap;
-import java.util.Map;
 import java.util.Iterator;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-import java.util.zip.ZipOutputStream;
+import java.util.Map;
 
 /**
  * Provides a collection of static methods to support comfortable loading and
@@ -87,6 +87,8 @@
  */
 public class PersistenceService implements XMLConstants {
     
+    private static final String LINE_SEPARATOR = System.getProperty("line.separator", "\n");
+    
     /**
      * This map maps from <code>Class</code> instances to
      * <code>PersistenceDelegate</code> instances. Its elements are installed
@@ -213,58 +215,19 @@
             PersistenceServiceException {
         if (xmlOut == null)
             throw new NullPointerException();
-        
-        // Guard against OutOfMemoryError here!
-        // This is not unlikely as XMLEncoder clones the root, which could be
-        // a large object graph.
-        // Remember: We guarantee to close the underlying stream, that's why
-        // we make a fuss out of this.
-        try {
-            OutputStream bufOut = null;
-            XMLEncoder encoder = null;
-            try {
-                bufOut = new BufferedOutputStream(xmlOut, BUFSIZE);
-                encoder = new XMLEncoder(bufOut);
-                installPersistenceDelegates(encoder);
-                encoder.setExceptionListener(createExceptionListener());
-                if (root != null) {
-                    synchronized (root) { // inhibit concurrent modifications - this requires cooperation
-                        encoder.writeObject(root);
-                    }
-                } else { // root == null
-                    encoder.writeObject(root);
-                }
-            } finally {
-                if (encoder != null) {
-                    try {
-                        // This method actually writes the XML content
-                        // and may throw an OutOfMemoryError (again)!
-                        encoder.close();
-                    } catch (Throwable paranoid) {
-                        // In case of an exception during the closing of
-                        // the encoder it does not properly close its
-                        // underlying stream. Do this now.
-                        bufOut.close();
-                        throw paranoid;
-                    }
-                } else if (bufOut != null) {
-                    // Allocating the encoder failed.
-                    // This should not normally happen unless the JVM is very
-                    // very scarce on heap memory!
-                    bufOut.close();
-                } else {
-                    // Allocating the buffered output stream failed.
-                    // This should not normally happen unless the JVM is very
-                    // very scarce on heap memory!
-                    xmlOut.close();
-                }
+        try
+        {
+            try
+            {
+                xmlOut.write(store2ByteArray(root));
             }
-        } catch (UndeclaredThrowableException exc) {
-            // Allocating a new exception should always succeed as the encoder
-            // and its associated clone of the root object graph is now
-            // eligible for garbage collection!
-            throw new PersistenceServiceException(exc.getCause()); // unwrap cause
-        } catch (Throwable thr) {
+            finally
+            {
+                xmlOut.close();
+            }
+        }
+        catch (Throwable thr)
+        {
             // Allocating a new exception should always succeed as the encoder
             // and its associated clone of the root object graph is now
             // eligible for garbage collection!
@@ -415,9 +378,7 @@
     public static byte[] store2ByteArray(Object root)
     throws  PersistenceServiceException {
         try {
-            ByteArrayOutputStream out = new ByteArrayOutputStream();
-            store(root, out);
-            return out.toByteArray();
+            return store2String(root).getBytes(XML_CHARSET);
         } catch (PersistenceServiceException exc) {
             throw exc;
         } catch (Throwable thr) {
@@ -445,15 +406,71 @@
      */
     public static String store2String(Object root)
     throws  PersistenceServiceException {
+        // Guard against OutOfMemoryError here!
+        // This is not unlikely as XMLEncoder clones the root, which could be
+        // a large object graph.
+        // Remember: We guarantee to close the underlying stream, that's why
+        // we make a fuss out of this.
         try {
-            ByteArrayOutputStream out = new ByteArrayOutputStream();
-            store(root, out);
-            return out.toString(XML_CHARSET);
+            ByteArrayOutputStream xmlOut = new ByteArrayOutputStream();
+            OutputStream bufOut = null;
+            XMLEncoder encoder = null;
+            try {
+                bufOut = new BufferedOutputStream(xmlOut, BUFSIZE);
+                encoder = new XMLEncoder(bufOut);
+                installPersistenceDelegates(encoder);
+                encoder.setExceptionListener(createExceptionListener());
+                if (root != null) {
+                    synchronized (root) { // inhibit concurrent modifications - this requires cooperation
+                        encoder.writeObject(root);
+                    }
+                } else { // root == null
+                    encoder.writeObject(root);
+                }
+            } finally {
+                if (encoder != null) {
+                    try {
+                        // This method actually writes the XML content
+                        // and may throw an OutOfMemoryError (again)!
+                        encoder.close();
+                    } catch (Throwable paranoid) {
+                        // In case of an exception during the closing of
+                        // the encoder it does not properly close its
+                        // underlying stream. Do this now.
+                        bufOut.close();
+                        throw paranoid;
+                    }
+                } else if (bufOut != null) {
+                    // Allocating the encoder failed.
+                    // This should not normally happen unless the JVM is very
+                    // very scarce on heap memory!
+                    bufOut.close();
+                } else {
+                    // Allocating the buffered output stream failed.
+                    // This should not normally happen unless the JVM is very
+                    // very scarce on heap memory!
+                    xmlOut.close();
+                }
+            }
+            
+            // Work around to IBM JDK bug. XMLEncoder uses a PrintWriter, producing \r\n sequences in Windows that are not preserved by XMLDecoder
+            String result = new String(xmlOut.toByteArray(), XML_CHARSET);
+            if ( !LINE_SEPARATOR.equals("\n") )
+            {
+                result = result.replace(LINE_SEPARATOR, "\n");
+            }
+            return result;            
+        } catch (UndeclaredThrowableException exc) {
+            // Allocating a new exception should always succeed as the encoder
+            // and its associated clone of the root object graph is now
+            // eligible for garbage collection!
+            throw new PersistenceServiceException(exc.getCause()); // unwrap cause
         } catch (UnsupportedEncodingException cannotHappen) {
             throw new AssertionError(cannotHappen);
-        } catch (PersistenceServiceException exc) {
-            throw exc;
         } catch (Throwable thr) {
+            // Allocating a new exception should always succeed as the encoder
+            // and its associated clone of the root object graph is now
+            // eligible for garbage collection!
             throw new PersistenceServiceException(thr);
         }
     }
